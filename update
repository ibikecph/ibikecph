#!/usr/bin/ruby

require 'rubygems'
require 'net/http'
require 'net/https'
require 'yaml'
require 'json'

config = YAML.load_file('update.yml')

USERNAME = config['username']
PASSWORD = config['password']
SERVER_ID = config['server_id']

SERVER_USER = 'osm'
SERVER_DOMAIN = 'worker-v1.ibikecph.dk'
SERVER_ROOT = '/home/osm'
SERVER_COMMAND = 'ibikecph/process osm osrm shutdown'    #skipping tiles for now. to run the full update cycle, simply use 'update'
API_HOSTNAME = 'https://cloudpanel.cloud.dk'

#HTTPI.log = false

class UpdateScheduler
  
  def get_status
    uri = URI("#{API_HOSTNAME}/virtual_machines/#{SERVER_ID}/status.json")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    request = Net::HTTP::Get.new(uri.path)
    request.basic_auth USERNAME, PASSWORD
    response = http.start {|http| http.request(request) }
    check_response response
    status = JSON.parse(response.body).first['virtual_machine']
    if status['locked'] == false
      if status['booted'] == true
        :up
      else
        :down
      end
    else
      :pending
    end
  end

  def up?
    get_status == :up
  end

  def wait_for_ssh
    puts 'Waiting for SSH'
    600.times do
      if system %{ssh #{SERVER_USER}@#{SERVER_DOMAIN} "whoami" 2>&1 > /dev/null}
        puts 'Server ready'
        return
      end
      sleep 1
    end
    raise "Timeout while waiting for SSH"
  end  

  def check_response response
    raise "API response code #{response.code}" unless [200,201].include? response.code.to_i
  end

  def startup
    uri = URI("#{API_HOSTNAME}/virtual_machines/#{SERVER_ID}/startup.json")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    request = Net::HTTP::Post.new(uri.path)
    request.basic_auth USERNAME, PASSWORD
    response = http.start {|http| http.request(request) }
    check_response response
  end
  
  def shutdown
    uri = URI("#{API_HOSTNAME}/virtual_machines/#{SERVER_ID}/shutdown.json")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    request = Net::HTTP::Post.new(uri.path)
    request.basic_auth USERNAME, PASSWORD
    response = http.start {|http| http.request(request) }
    check_response response
  end

  def up
    puts "--------"
    unless up?
      puts "Starting update server at #{Time.now}"
      startup
    else
      puts "Update server already up"
    end
    wait_for_ssh
  end

  def down
    puts "--------"
    if up?
      puts "Shutting down update server at #{Time.now}"
      shutdown
    else
      puts "Update server already down"
    end
  end

  def status
    puts get_status
  end

  def update
    puts "--------"
    puts "Starting update at #{Time.now}"
    ensure_up

    #run script in background using '&'
    #use nohup, so it's not terminated when we log out of ssh
    #to avoid ssh hanging, make sure to redirect all three stream: stdout, stderr, stdin
    puts "Initiating remote update at #{Time.now}... "
    if system %{ssh #{SERVER_USER}@#{SERVER_DOMAIN} "nohup #{SERVER_ROOT}/#{SERVER_COMMAND} >> #{SERVER_ROOT}/update.log 2>&1 < /dev/null &"}
      puts 'OK'
      #we're done, remote script will handle shutdown after it finishes
    else
      raise '*** Failed to initiate remote update!'
    end
  rescue Exception => e
    puts e
    #if something goes wrong, ensure shutdown
    shutdown
  ensure
    puts "\n\n"
  end
end


scheduler = UpdateScheduler.new

if ARGV[0]==nil
  #scheduler.update
elsif ARGV[0]=='up'
  scheduler.up
elsif ARGV[0]=='down'
  scheduler.down
elsif ARGV[0]=='status'
  scheduler.status
elsif ARGV[0]=='test'
  puts "Test at #{Time.now}... "
end